{
    "componentChunkName": "component---node-modules-gatsby-theme-code-notes-src-templates-note-js",
    "path": "/python-typing",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Python Typing\",\n  \"tags\": [\"python\"],\n  \"emoji\": \"üêç\",\n  \"link\": \"https://docs.python.org/3/library/typing.html\",\n  \"description\": \"All about of Python types\",\n  \"modified\": \"2025-06-02T00:00:00.000Z\",\n  \"date\": \"2025-06-02T18:59:34.511Z\",\n  \"draft\": false,\n  \"categories\": [\"type\", \"python\", \"programming\", \"class\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"typing\"\n  }, \"Typing\"), mdx(\"p\", null, \"The Python runtime does not enforce function and variable type annotations. They can be used by third party tools such as type checkers, IDEs, linters, etc.\"), mdx(\"h2\", {\n    \"id\": \"type-aliases\"\n  }, \"Type aliases\"), mdx(\"p\", null, \"A type alias is defined using the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.python.org/3/reference/simple_stmts.html#type\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"type\")), \" statement, which creates an instance of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.python.org/3/library/typing.html#typing.TypeAliasType\",\n    \"title\": \"typing.TypeAliasType\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"TypeAliasType\")), \". In this example, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Vector\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"list[float]\"), \" will be treated equivalently by static type checkers:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"type Vector = list[float]\\n\\ndef scale(scalar: float, vector: Vector) -> Vector:\\n    return [scalar * num for num in vector]\\n\\n# passes type checking; a list of floats qualifies as a Vector.\\nnew_vector = scale(2.0, [1.0, -4.2, 5.4])\\n\")), mdx(\"p\", null, \"Before Python 3.12, you marked with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.python.org/3/library/typing.html#typing.TypeAlias\",\n    \"title\": \"typing.TypeAlias\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"TypeAlias\")), \" to make it explicit that this is a type alias, not a normal variable assignment:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from typing import TypeAlias\\n\\nVector: TypeAlias = list[float]\\n\")), mdx(\"h2\", {\n    \"id\": \"newtype\"\n  }, \"NewType\"), mdx(\"p\", null, \"Use the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.python.org/3/library/typing.html#typing.NewType\",\n    \"title\": \"typing.NewType\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"NewType\")), \" helper to create distinct types:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from typing import NewType\\n\\nUserId = NewType('UserId', int)\\nsome_id = UserId(524313)\\n\")), mdx(\"p\", null, \"You may still perform all \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int\"), \" operations on a variable of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UserId\"), \", but the result will always be of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int\"), \". This lets you pass in a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UserId\"), \" wherever an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int\"), \" might be expected, but will prevent you from accidentally creating a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UserId\"), \" in an invalid way:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"# 'output' is of type 'int', not 'UserId'\\noutput = UserId(23413) + UserId(54341)\\n\")), mdx(\"p\", null, \"It is possible to create a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.python.org/3/library/typing.html#typing.NewType\",\n    \"title\": \"typing.NewType\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"NewType\")), \" based on a \\u2018derived\\u2019 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NewType\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from typing import NewType\\n\\nUserId = NewType('UserId', int)\\n\\nProUserId = NewType('ProUserId', UserId)\\n\")), mdx(\"h2\", {\n    \"id\": \"annotating-callable-objects\"\n  }, \"Annotating callable objects\"), mdx(\"p\", null, \"Functions \\u2013 or other \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.python.org/3/glossary.html#term-callable\"\n  }, \"callable\"), \" objects \\u2013 can be annotated using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable\",\n    \"title\": \"collections.abc.Callable\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"collections.abc.Callable\")), \" or deprecated \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.python.org/3/library/typing.html#typing.Callable\",\n    \"title\": \"typing.Callable\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"typing.Callable\")), \". \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Callable[[int], str]\"), \" signifies a function that takes a single parameter of type \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.python.org/3/library/functions.html#int\",\n    \"title\": \"int\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"int\")), \" and returns a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.python.org/3/library/stdtypes.html#str\",\n    \"title\": \"str\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"str\")), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from collections.abc import Callable, Awaitable\\n\\ndef feeder(get_next_item: Callable[[], str]) -> None:\\n    ...  # Body\\n\\ndef async_query(on_success: Callable[[int], None],\\n                on_error: Callable[[int, Exception], None]) -> None:\\n    ...  # Body\\n\\nasync def on_update(value: str) -> None:\\n    ...  # Body\\n\\ncallback: Callable[[str], Awaitable[None]] = on_update\\n\")), mdx(\"h2\", {\n    \"id\": \"generics\"\n  }, \"Generics\"), mdx(\"p\", null, \"Since type information about objects kept in containers cannot be statically inferred in a generic way, many container classes in the standard library support subscription to denote the expected types of container elements.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from collections.abc import Mapping, Sequence\\n\\nclass Employee: ...\\n\\n# Sequence[Employee] indicates that all elements in the sequence\\n# must be instances of \\\"Employee\\\".\\n# Mapping[str, str] indicates that all keys and all values in the mapping\\n# must be strings.\\ndef notify_by_email(employees: Sequence[Employee],\\n                    overrides: Mapping[str, str]) -> None: ...\\n\")), mdx(\"p\", null, \"Generic functions and classes can be parameterized by using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.python.org/3/reference/compound_stmts.html#type-params\"\n  }, \"type parameter syntax\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from collections.abc import Sequence\\n\\ndef first[T](l: Sequence[T]) -> T:  # Function is generic over the TypeVar \\\"T\\\"\\n    return l[0]\\n\")), mdx(\"p\", null, \"Or by using the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.python.org/3/library/typing.html#typing.TypeVar\",\n    \"title\": \"typing.TypeVar\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"TypeVar\")), \" factory directly:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from collections.abc import Sequence\\nfrom typing import TypeVar\\n\\nU = TypeVar('U')                  # Declare type variable \\\"U\\\"\\n\\ndef second(l: Sequence[U]) -> U:  # Function is generic over the TypeVar \\\"U\\\"\\n    return l[1]\\n\")), mdx(\"h2\", {\n    \"id\": \"annotating-tuples\"\n  }, \"Annotating tuples\"), mdx(\"p\", null, \"For most containers in Python, the typing system assumes that all elements in the container will be of the same type.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from collections.abc import Mapping\\n\\n# Type checker will infer that all elements in ``x`` are meant to be ints\\nx: list[int] = []\\n\\n# Type checker error: ``list`` only accepts a single type argument:\\ny: list[int, str] = [1, 'foo']\\n\\n# Type checker will infer that all keys in ``z`` are meant to be strings,\\n# and that all values in ``z`` are meant to be either strings or ints\\nz: Mapping[str, str | int] = {}\\n\")), mdx(\"p\", null, \"To denote a tuple which could be of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"any\"), \" length, and in which all elements are of the same type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"T\"), \", use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tuple[T, ...]\"), \". To denote an empty tuple, use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tuple[()]\"), \". Using plain \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tuple\"), \" as an annotation is equivalent to using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tuple[Any, ...]\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"x: tuple[int, ...] = (1, 2)\\n# These reassignments are OK: ``tuple[int, ...]`` indicates x can be of any length\\nx = (1, 2, 3)\\nx = ()\\n# This reassignment is an error: all elements in ``x`` must be ints\\nx = (\\\"foo\\\", \\\"bar\\\")\\n\\n# ``y`` can only ever be assigned to an empty tuple\\ny: tuple[()] = ()\\n\\nz: tuple = (\\\"foo\\\", \\\"bar\\\")\\n# These reassignments are OK: plain ``tuple`` is equivalent to ``tuple[Any, ...]``\\nz = (1, 2, 3)\\nz = ()\\n\")), mdx(\"h2\", {\n    \"id\": \"the-type-of-class-objects\"\n  }, \"The type of class objects\"), mdx(\"p\", null, \"A variable annotated with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"C\"), \" may accept a value of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"C\"), \". In contrast, a variable annotated with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"type[C]\"), \" (or deprecated \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.python.org/3/library/typing.html#typing.Type\",\n    \"title\": \"typing.Type\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"typing.Type[C]\")), \") may accept values that are classes themselves \\u2013 specifically, it will accept the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"class object\"), \" of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"C\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"class User: ...\\nclass ProUser(User): ...\\nclass TeamUser(User): ...\\n\\ndef make_new_user(user_class: type[User]) -> User:\\n    # ...\\n    return user_class()\\n\\nmake_new_user(User)      # OK\\nmake_new_user(ProUser)   # Also OK: ``type[ProUser]`` is a subtype of ``type[User]``\\nmake_new_user(TeamUser)  # Still fine\\nmake_new_user(User())    # Error: expected ``type[User]`` but got ``User``\\nmake_new_user(int)       # Error: ``type[int]`` is not a subtype of ``type[User]``\\n\")), mdx(\"h2\", {\n    \"id\": \"annotating-generators-and-coroutines\"\n  }, \"Annotating generators and coroutines\"), mdx(\"p\", null, \"A generator can be annotated using the generic type \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.python.org/3/library/collections.abc.html#collections.abc.Generator\",\n    \"title\": \"collections.abc.Generator\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Generator[YieldType, SendType, ReturnType]\")), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def echo_round() -> Generator[int, float, str]:\\n    sent = yield 0\\n    while sent >= 0:\\n        sent = yield round(sent)\\n    return 'Done'\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SendType\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ReturnType\"), \" parameters default to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"None\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def infinite_stream(start: int) -> Generator[int]:  # or Generator[int, None, None]\\n    while True:\\n        yield start\\n        start += 1\\n\")), mdx(\"p\", null, \"Simple generators that only ever yield values can also be annotated as having a return type of either \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable\",\n    \"title\": \"collections.abc.Iterable\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Iterable[YieldType]\")), \" or \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterator\",\n    \"title\": \"collections.abc.Iterator\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Iterator[YieldType]\")), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def infinite_stream(start: int) -> Iterator[int]:\\n    while True:\\n        yield start\\n        start += 1\\n\")), mdx(\"p\", null, \"Async generators are handled in a similar fashion, but don\\u2019t expect a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ReturnType\"), \" type argument (\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.python.org/3/library/collections.abc.html#collections.abc.AsyncGenerator\",\n    \"title\": \"collections.abc.AsyncGenerator\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"AsyncGenerator[YieldType, SendType]\")), \"). The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SendType\"), \" argument defaults to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"None\"), \", so the following definitions are equivalent:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"async def infinite_stream(start: int) -> AsyncGenerator[int]:\\n    while True:\\n        yield start\\n        start = await increment(start)\\n\\nasync def infinite_stream(start: int) -> AsyncGenerator[int, None]:\\n    while True:\\n        yield start\\n        start = await increment(start)\\n\")), mdx(\"h2\", {\n    \"id\": \"user-defined-generic-types\"\n  }, \"User-defined generic types\"), mdx(\"p\", null, \"A user-defined class can be defined as a generic class.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from logging import Logger\\n\\nclass LoggedVar[T]:\\n    def __init__(self, value: T, name: str, logger: Logger) -> None:\\n        self.name = name\\n        self.logger = logger\\n        self.value = value\\n\\n    def set(self, new: T) -> None:\\n        self.log('Set ' + repr(self.value))\\n        self.value = new\\n\\n    def get(self) -> T:\\n        self.log('Get ' + repr(self.value))\\n        return self.value\\n\\n    def log(self, message: str) -> None:\\n        self.logger.info('%s: %s', self.name, message)\\n\")), mdx(\"p\", null, \"This syntax indicates that the class \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LoggedVar\"), \" is parameterised around a single \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.python.org/3/library/typing.html#typevar\"\n  }, \"type variable\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"T\"), \" . This also makes \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"T\"), \" valid as a type within the class body.\"), mdx(\"p\", null, \"Generic classes implicitly inherit from \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.python.org/3/library/typing.html#typing.Generic\",\n    \"title\": \"typing.Generic\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Generic\")), \". For compatibility with Python 3.11 and lower, it is also possible to inherit explicitly from \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.python.org/3/library/typing.html#typing.Generic\",\n    \"title\": \"typing.Generic\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Generic\")), \" to indicate a generic class:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from typing import TypeVar, Generic\\n\\nT = TypeVar('T')\\n\\nclass LoggedVar(Generic[T]):\\n    ...\\n\")), mdx(\"p\", null, \"Generic classes have \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.python.org/3/reference/datamodel.html#object.__class_getitem__\",\n    \"title\": \"object.__class_getitem__\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"__class_getitem__()\")), \" methods, meaning they can be parameterised at runtime (e.g. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LoggedVar[int]\"), \" below):\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from collections.abc import Iterable\\n\\ndef zero_all_vars(vars: Iterable[LoggedVar[int]]) -> None:\\n    for var in vars:\\n        var.set(0)\\n\")), mdx(\"p\", null, \"A generic type can have any number of type variables. All varieties of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.python.org/3/library/typing.html#typing.TypeVar\",\n    \"title\": \"typing.TypeVar\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"TypeVar\")), \" are permissible as parameters for a generic type:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from typing import TypeVar, Generic, Sequence\\n\\nclass WeirdTrio[T, B: Sequence[bytes], S: (int, str)]:\\n    ...\\n\\nOldT = TypeVar('OldT', contravariant=True)\\nOldB = TypeVar('OldB', bound=Sequence[bytes], covariant=True)\\nOldS = TypeVar('OldS', int, str)\\n\\nclass OldWeirdTrio(Generic[OldT, OldB, OldS]):\\n    ...\\n\")), mdx(\"h2\", {\n    \"id\": \"the-typingany-type\"\n  }, \"The \", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"https://docs.python.org/3/library/typing.html#typing.Any\",\n    \"title\": \"typing.Any\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Any\")), \" type\"), mdx(\"p\", null, \"A special kind of type is \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.python.org/3/library/typing.html#typing.Any\",\n    \"title\": \"typing.Any\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Any\")), \". A static type checker will treat every type as being compatible with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.python.org/3/library/typing.html#typing.Any\",\n    \"title\": \"typing.Any\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Any\")), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.python.org/3/library/typing.html#typing.Any\",\n    \"title\": \"typing.Any\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Any\")), \" as being compatible with every type.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"from typing import Any\\n\\na: Any = None\\na = []          # OK\\na = 2           # OK\\n\\ns: str = ''\\ns = a           # OK\\n\\ndef foo(item: Any) -> int:\\n    # Passes type checking; 'item' could be any type,\\n    # and that type might have a 'bar' method\\n    item.bar()\\n    ...\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Python Typing","tags":["python"],"emoji":"üêç","link":"https://docs.python.org/3/library/typing.html","modified":"June 2, 2025","modifiedTimestamp":"2025-06-02T00:00:00.000Z"},"references":[],"fields":{"slug":"/python-typing"},"tableOfContents":{"items":[{"url":"#typing","title":"Typing","items":[{"url":"#type-aliases","title":"Type aliases"},{"url":"#newtype","title":"NewType"},{"url":"#annotating-callable-objects","title":"Annotating callable objects"},{"url":"#generics","title":"Generics"},{"url":"#annotating-tuples","title":"Annotating tuples"},{"url":"#the-type-of-class-objects","title":"The type of class objects"},{"url":"#annotating-generators-and-coroutines","title":"Annotating generators and coroutines"},{"url":"#user-defined-generic-types","title":"User-defined generic types"},{"url":"#the-typingany-type","title":"The typing.Any type"}]}]},"parent":{"relativePath":"python-typing.md"}}},"pageContext":{"id":"fee471c0-769e-521c-a1cb-1a1ccc5d16b5","previous":null,"next":{"id":"ff5f6f27-2254-51aa-872a-ea52ae0040e9","frontmatter":{"title":"Welcome to \"Life of Code\"","tags":["general"]},"fields":{"slug":"/welcome"}},"hasUntagged":false,"basePath":"/","tags":[{"tag":"general","totalCount":1,"slug":"/general","path":"/tag/general"},{"tag":"python","totalCount":6,"slug":"/python","path":"/tag/python"}]}},
    "staticQueryHashes": ["2566719832","2744905544","467212769"]}