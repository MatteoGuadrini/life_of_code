{
    "componentChunkName": "component---node-modules-gatsby-theme-code-notes-src-templates-note-js",
    "path": "/python-paradigm",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"Python Paradigm\",\n  \"tags\": [\"python\"],\n  \"emoji\": \"üêç\",\n  \"link\": \"https://docs.python.org/3/howto/functional.html\",\n  \"description\": \"Programming Paradigm in Python Meaning\",\n  \"modified\": \"2024-10-26T00:00:00.000Z\",\n  \"date\": \"2024-10-26T14:42:58.264Z\",\n  \"draft\": false,\n  \"categories\": [\"paradigm\", \"python\", \"programming\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"programming-paradigm-in-python\"\n  }, \"Programming Paradigm in Python\"), mdx(\"p\", null, \"A \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"programming paradigm\"), \" is a fundamental style or approach to writing code. It encompasses a set of principles, concepts, and methodologies that guide how a programmer designs, organizes, and implements code. \"), mdx(\"p\", null, \"Different paradigms emphasize distinct aspects of programming, such as data organization, control flow, and modularity. Each paradigm has its own key features that define its scope and application.\"), mdx(\"h2\", {\n    \"id\": \"key-features-of-programming-paradigms\"\n  }, \"Key features of programming paradigms\"), mdx(\"p\", null, \"Each paradigm has many key features.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Data Structure\"), \": How data is organized, stored, and manipulated.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Control Flow\"), \": How instructions are executed and decisions are made.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Modularity\"), \": How code is organized into reusable and maintainable modules.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Abstraction\"), \": The level of detail and complexity exposed to the programmer.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Inheritance and Composition\"), \": How code can be reused and extended.\")), mdx(\"h2\", {\n    \"id\": \"imperative-procedural-programming\"\n  }, \"Imperative (Procedural) Programming\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Imperative programming\"), \" or \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Procedural programming\"), \" is one of the most intuitive paradigms, focusing on describing the step-by-step sequence of instructions required to achieve a specific goal. It revolves around changing program state through statements that modify variables and data structures.\"), mdx(\"p\", null, \"In Python, imperative programming is evident in the straightforward sequence of statements that update variables, perform calculations, and control flow. The paradigm\\u2019s simplicity makes it an ideal choice for tasks where control over individual instructions is critical.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"numbers = [1, 2, 3, 4, 5]\\nresult = 0\\nfor number in numbers:\\n    result += number\\nprint(result)\\n\")), mdx(\"h2\", {\n    \"id\": \"declarative-programming\"\n  }, \"Declarative Programming\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Declarative programming\"), \" focuses on specifying what should be done rather than how it should be done. It promotes a more abstract and high-level approach to problem-solving. \"), mdx(\"p\", null, \"In Python, list comprehensionsa and generator expressions exemplify declarative programming. This paradigm leads to more concise and readable code by abstracting away implementation details.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"numbers = [1, 2, 3, 4, 5]\\neven_numbers = [n for n in numbers if n % 2 == 0]\\nprint(even_numbers)\\n\")), mdx(\"h2\", {\n    \"id\": \"functional-programming\"\n  }, \"Functional Programming\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Functional programming\"), \" treats computation as the evaluation of mathematical functions and avoids changing state and mutable data. It emphasizes immutable data and the use of pure functions that produce consistent outputs for the same inputs. \"), mdx(\"p\", null, \"Python supports functional programming through features like lambda functions, higher-order functions, and tools like map, filter, and reduce.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def square(number):\\n    return number ** 2\\n\\nnumbers = [1, 2, 3, 4, 5]\\nsquares = list(map(square, numbers))\\nprint(squares)\\n\")), mdx(\"h2\", {\n    \"id\": \"object-oriented-programming-oop\"\n  }, \"Object-Oriented Programming (OOP)\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Object-Oriented Programming (OOP)\"), \" revolves around the concept of objects, which encapsulate both data (\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"attributes\"), \") and behavior (\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"methods\"), \") related to a specific entity. This paradigm emphasizes code modularity, reusability, and the modeling of real-world entities as classes. \"), mdx(\"p\", null, \"Python renowned for its support of OOP, allowing developers to create classes, define inheritance hierarchies, and achieve polymorphism through method overriding and interfaces.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"class Car:\\n\\n    def __init__(self, brand, model):\\n        self.brand = brand\\n        self.model = model\\n    \\n    def start_engine():\\n        print(f\\\"the {self.brand} {self.model}'s engine is running...\\\")\\n\\nmy_car = Car(\\\"Toyota\\\", \\\"Yaris\\\")\\nmy_car.start_engine()\\n\")), mdx(\"h2\", {\n    \"id\": \"parallel-programming\"\n  }, \"Parallel Programming\"), mdx(\"p\", null, \"Python offers powerful libraries like asyncio and threading for concurrent programming and multiprocessing for parallel execution. \"), mdx(\"p\", null, \"The asyncio library facilitates asynchronous programming, enabling tasks to run concurrently without blocking the main program. This is especially useful for I/O-bound tasks such as network requests.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"import asyncio\\n\\nasync def fetch_data() -> dict:\\n    await asyncio.sleep(2)\\n    return {'data': 'fetched'}\\n\\nif __name__ == '__main__':\\n    result = asyncio.run(fetch_data())\\n    print(result)\\n\")), mdx(\"h2\", {\n    \"id\": \"metaprogramming\"\n  }, \"Metaprogramming\"), mdx(\"p\", null, \"Python\\u2019s dynamic and introspective features enable powerful metaprogramming techniques. Metaprogramming involves writing code that manipulates or generates other code. Decorators and Metaclass, for instance, are a form of metaprogramming in Python. \"), mdx(\"p\", null, \"They allow you to modify the behavior of functions or classes without changing their source code. This advanced paradigm empowers developers to create reusable and flexible code structures.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"# Metaclass\\nclass OnlyOneBases(type):\\n    def __new__(cls, clsname, bases, clsdict):\\n        if len(bases) > 1:\\n            raise TypeError(\\\"Inherited multiple base classes!!!\\\")\\n        return super().__new__(cls, clsname, bases, clsdict)\\n\\nclass Base(metaclass=OnlyOneBases):\\n    pass\\n\\n# no error is raised\\nclass A(Base):\\n    pass\\n\\n# no error is raised\\nclass B(Base):\\n    pass\\n\\n# This will raise an error!\\nclass C(A, B):\\n    pass\\n\\n# Decorators\\ndef make_pretty(func):\\n    def inner():\\n        print(\\\"I got decorated\\\")\\n        func()\\n    return inner\\n\\n@make_pretty\\ndef ordinary():\\n    print(\\\"I am ordinary\\\")\\n\\nordinary()\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Python Paradigm","tags":["python"],"emoji":"üêç","link":"https://docs.python.org/3/howto/functional.html","modified":"October 26, 2024","modifiedTimestamp":"2024-10-26T00:00:00.000Z"},"references":[],"fields":{"slug":"/python-paradigm"},"tableOfContents":{"items":[{"url":"#programming-paradigm-in-python","title":"Programming Paradigm in Python","items":[{"url":"#key-features-of-programming-paradigms","title":"Key features of programming paradigms"},{"url":"#imperative-procedural-programming","title":"Imperative (Procedural) Programming"},{"url":"#declarative-programming","title":"Declarative Programming"},{"url":"#functional-programming","title":"Functional Programming"},{"url":"#object-oriented-programming-oop","title":"Object-Oriented Programming (OOP)"},{"url":"#parallel-programming","title":"Parallel Programming"},{"url":"#metaprogramming","title":"Metaprogramming"}]}]},"parent":{"relativePath":"python-paradigm.md"}}},"pageContext":{"id":"69b35775-847b-5e56-98a7-ae98329861ee","previous":{"id":"d4f1a493-2b3f-593e-90a0-665591721943","frontmatter":{"title":"Python Functions","tags":["python"]},"fields":{"slug":"/python-functions"}},"next":{"id":"c90c52bd-6dc9-55e5-83eb-c177e78db654","frontmatter":{"title":"Python Literals","tags":["python"]},"fields":{"slug":"/python-literals"}},"hasUntagged":false,"basePath":"/","tags":[{"tag":"general","totalCount":1,"slug":"/general","path":"/tag/general"},{"tag":"python","totalCount":5,"slug":"/python","path":"/tag/python"}]}},
    "staticQueryHashes": ["2566719832","2744905544","467212769"]}